{- hus-custom-wavetable X [wavetable-in.wav] < pattern.hus

   X is a number from 1 to 8 specifying the X mode

   wavtable-in.wav is an optional wavetable from a previuos run. The new
   wavetable will be concatenated to the old one.

   Fails if 256 waveform limit is exceeded

   Gene an expanded, transposed (horizontal, if you will) file like

    PINA XXHHHHLLL
    PINB 01101Z010

To binary bytes as given by the wavetable

TODO This is a bit slower than I'd like
-}

{-# LANGUAGE OverloadedStrings #-}

import qualified Data.ByteString.Char8 as B
import qualified Data.HashMap.Strict as Map
import qualified Data.HashSet as Set

import Lib

chunksOfBS :: Int -> ByteString -> [ByteString]
chunksOfBS n bs
  | B.null bs = []
  | otherwise = B.take n bs : chunksOfBS n (B.drop n bs)

unique :: Hashable a => Eq a => [a] -> [a]
unique = Set.toList . Set.fromList

mkTable :: Int -> ByteString -> WaveTable
mkTable xmode inp =
  let
    [pin, statesIn] = B.words inp
    states = pad xmode . canonical $ statesIn
    table = sort . unique . nub . chunksOfBS xmode $ states
  in
    WaveTable [pin] table

combine :: [WaveTable] -> WaveTable
combine inp =
  WaveTable (concatMap pins inp) (waves (head inp))

format :: WaveTable -> ByteString
format inp =
  B.concat [ "PINS ", B.unwords (pins inp), "\n"
           , B.unlines $ formatWaves (waves inp)]
  where
    formatWaves = zipWith spacer (map (B.pack . show) ([0..] :: [Int]) )
    spacer a b = B.unwords [a,b]

data Opts =
  Opts
  { xmode :: Int
  , input :: FilePath -- Input
  , waveTableFile :: FilePath
  }

parseOpts :: OptionsParser Opts
parseOpts = Opts
  <$> argument auto
      (  metavar "XMODE"
      <> help "X mode number from 1 to 8")
  <*> argument str
      (  metavar "HUSFILE.hus"
      <> value ""
      <> help "A Horizontal-Uncompressed State file")
  <*> strOption
      (  long "wavetable"
      <> short 'w'
      <> value ""
      <> metavar "FILENAME"
      <> help "Wavetable generated by previous run. We'll only add to it")

opts :: ParserInfo Opts
opts = info (parseOpts <**> helper)
  ( fullDesc
  <> progDesc "Generate a custom wavetable with all combinations required for input.hus file"
  <> header "hus-custom-wavetable - custom wavetable generator")

breakWaves :: [WaveTable] -> [WaveTable]
breakWaves = concat . map go
  where
    go (WaveTable ps ws) = map (\p -> WaveTable [ p ] ws) ps

appendTable :: HashMap ByteString WaveTable -> WaveTable -> WaveTable
appendTable oldWaveMap newTable =
  let
    oldTable :: Maybe WaveTable
    oldTable = Map.lookup (head . pins $ newTable) oldWaveMap
    appendWaves :: [ByteString] -> [ByteString] -> [ByteString]
    appendWaves old new =
      let
        oldSet = Set.fromList old
        newSet = Set.fromList new
        newUnique = sort . Set.toList $ Set.difference newSet oldSet
      in
        old ++ newUnique
  in
    case oldTable of
      Nothing -> newTable
      Just (WaveTable p ws) -> WaveTable p ( appendWaves ws (waves newTable) )

main :: IO ()
main = do
  Opts xmode inputFile waveTableFile <- execParser opts
  contents <- getInput inputFile

  oldWaves <-
    if null waveTableFile
      then return []
      else readWaveTables waveTableFile

  let
    oldWaveMap = Map.fromList . map (\wt -> (head . pins $ wt, wt)) . breakWaves $ oldWaves
    rawTables = map (mkTable xmode) (B.lines contents)
    newTables = map (appendTable oldWaveMap) rawTables
    combined = map combine . groupBy ((==) `on` waves ) . sortBy (compare `on` waves ) $ newTables
    tooBig :: [WaveTable]
    tooBig = filter (( >256 ) . length . waves) combined

  mapM_ (B.putStr . format)  combined

  unless (null tooBig)
    ( error $ unlines
      ["Some wave tables are longer than 256 waves. Output generated anyway to help you debug."
      ,"Offending pins:"
      ,unlines ( map (unwords . map B.unpack . pins ) tooBig )
      ])
